"""
Kernel module - atomic operations for execution
"""

import json
import time
import os
from pathlib import Path
from typing import Optional
from skillpilot.protocol.request import Request
from skillpilot.protocol.ack import Ack


class ExecutionKernel:
    """Execution kernel - handles atomic operations"""

    def __init__(self, run_dir: Path, queue_timeout_s: int = 300):
        self.run_dir = run_dir
        self.queue_timeout_s = queue_timeout_s
        self.scripts_dir = run_dir / "scripts"
        self.reports_dir = run_dir / "reports"
        self.queue_dir = run_dir / "queue"
        self.ack_dir = run_dir / "ack"
        
        # Create directories
        for d in [self.scripts_dir, self.reports_dir, self.queue_dir, self.ack_dir]:
            d.mkdir(parents=True, exist_ok=True)

    def write_restore_wrapper(self, enc_path: Path) -> Path:
        """Generate restore_wrapper.tcl"""
        wrapper_path = self.scripts_dir / "restore_wrapper.tcl"
        enc_dir = enc_path.parent
        enc_name = enc_path.name
        
        content = f"""# restore_wrapper.tcl
# Generated by SkillPilot

# CD to enc directory (critical for relative path dependencies)
cd {enc_dir}

# Source the enc file
source {enc_name}

puts "Restore completed: {enc_name}"
"""
        wrapper_path.write_text(content)
        return wrapper_path

    def write_run_skill_script(self, skill_name: str) -> Path:
        """Generate run skill script"""
        script_path = self.scripts_dir / f"run_{skill_name}.tcl"
        
        content = f"""# run_{skill_name}.tcl
# Generated by SkillPilot

puts "Running skill: {skill_name}"

# Place skill execution logic here
# Results should be written to reports/ directory

puts "Skill completed: {skill_name}"
"""
        script_path.write_text(content)
        return script_path

    def submit_request(self, job_id: str, script: str, timeout_s: Optional[int] = None) -> str:
        """Submit request and return request_id"""
        request = Request(
            job_id=job_id,
            action="SOURCE_TCL",
            script=script,
            timeout_s=timeout_s or self.queue_timeout_s,
        )
        request_path = request.write_atomic(self.run_dir)
        return request.request_id

    def wait_for_ack(self, request_id: str) -> Ack:
        """Wait for ack and return it"""
        start = time.time()
        ack_path = self.ack_dir / f"{request_id}.json"
        
        while time.time() - start < self.queue_timeout_s:
            if ack_path.exists():
                return Ack.read(self.run_dir, request_id)
            time.sleep(0.1)
        
        # Timeout
        raise TimeoutError(f"Queue timeout waiting for ack: {request_id}")

    def check_ack_exists(self, request_id: str) -> bool:
        """Check if ack exists"""
        ack_path = self.ack_dir / f"{request_id}.json"
        return ack_path.exists()
